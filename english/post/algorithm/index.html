<!DOCTYPE html>
<html  dir="ltr" lang="en" data-theme=""><head>
    <title> Chi Feng | 算法相关 </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.92.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="差不多得了">
    
    
    
    <link rel="stylesheet"
        href="/css/main.min.cf3bc06a9d8faea75a336d59c26f1f005581c5797c997ea627faf957fef00abc.css"
        integrity="sha256-zzvAap2PrqdaM21Zwm8fAFWBxXl8mX6mJ/r5V/7wCrw="
        crossorigin="anonymous"
        type="text/css">
    
    
    <link rel="stylesheet"
        href="/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css"
        integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS&#43;yuWSR4="
        crossorigin="anonymous"
        type="text/css">
    
    <link rel="stylesheet" 
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" 
    integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" 
    crossorigin="anonymous" />
    
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

    <link rel="canonical" href="/english/post/algorithm/">

    
    
    
    
    <script type="text/javascript"
            src="/js/anatole-header.min.98b79432dfa53ecc682fb19247f797a316f8cbca9d5455c8bb22e58fc694b675.js"
            integrity="sha256-mLeUMt&#43;lPsxoL7GSR/eXoxb4y8qdVFXIuyLlj8aUtnU="
            crossorigin="anonymous"></script>


    
        
        
        <script type="text/javascript"
                src="/js/anatole-theme-switcher.min.7fd87181cdd7e8413aa64b6867bb32f3a8dc242e684fc7d5bbb9f600dbc2b6eb.js"
                integrity="sha256-f9hxgc3X6EE6pktoZ7sy86jcJC5oT8fVu7n2ANvCtus="
                crossorigin="anonymous"></script>
    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="算法相关"/>
<meta name="twitter:description" content="算法小结 树 dfs 深搜 遍历并加入res
class TreeNode: def __init__(self, val=0, left=None, right=None): self."/>


    

</head>
<body>
<header><div class="page-top animated fadeInDown">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <nav>
        <ul class="nav__list" id="navMenu">
            <div class="nav__links">
                
                
                
            </div>
            <li>
                
                <a class="theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
                
            </li>
        </ul>
    </nav>
</div>
</header>
<div class="wrapper">
    <aside><div class="sidebar animated fadeInDown ">
    <div class="sidebar__content">
        <div class="logo-title">
            <div class="title">
                <img src="/images/avatar.jpg" alt="profile picture">
                <h3 title=""><a href="/">冯  驰</a></h3>
                <div class="description">
                    <p>差不多得了</p>
                </div>
            </div>
        </div>
        <ul class="social-links">
            
        </ul>
    </div><footer class="footer footer--sidebar">        
    <div class="by_farbox">
        <ul class="footer__list">
            <li class="footer__item">&copy;
                
                    Chi Feng 2024
                
            </li>
            
        </ul>
    </div>
</footer>

<script type="text/javascript"
        src="/js/medium-zoom.min.83cb1dd5fea8d42d87d1e601a07faa73089ad0ef9ccfe5daf6041289ebcc4e46.js"
        integrity="sha256-g8sd1f6o1C2H0eYBoH&#43;qcwia0O&#43;cz&#43;Xa9gQSievMTkY="
        crossorigin="anonymous"></script></div>
</aside>
    <main>
        <div class="autopagerize_page_element">
            <div class="content">
    <div class="post  animated fadeInDown ">
        <div class="post-content">
            
            <div class="post-title">
                <h3>算法相关</h3>
                
            </div>

            <h1 id="算法小结">算法小结</h1>
<h2 id="树">树</h2>
<h3 id="dfs-深搜">dfs 深搜</h3>
<p>遍历并加入res</p>
<pre tabindex="0"><code>class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
def dfs(self, nd, res):
    if not nd: # 空节点，直接返回
        return
    if nd.left: # 如果有左节点，访问左节点
        self.dfs(nd.left, res)
    res.append(nd.val) # 加入当前节点的值到列表
    if nd.right: # 中节点访问完毕，访问右节点
        self.dfs(nd.right, res)
    return res 
</code></pre><h3 id="bfs-广搜">bfs 广搜</h3>
<p>从左到右遍历并加入res</p>
<pre tabindex="0"><code>class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
    if not root:
        return []
    q = collections.deque()
    q.append(root) #根节点入开启队列
    res = []
    while q:
        cur_row = [] # 当前行初始化
        for i in range(len(q)): # 当前队列的所节点取长度，不能直接遍历因为过程中会加入新节点
            nd = q.popleft() # 左向弹出一个节点
            cur_row.append(nd.val)  # 节点值加入res列表
            # 如果当前节点有子节点则加入
            if nd.left: 
                q.append(nd.left)
            if nd.right:
                q.append(nd.right)
        res.append(cur_row)
    return res

</code></pre><h3 id="中序遍历的前驱节点">中序遍历的前驱节点</h3>
<ol>
<li>有左子节点，则返回左节点</li>
<li>无左节点则返回父节点</li>
<li>根节点无父节点，所以先定义一个空节点</li>
</ol>
<pre tabindex="0"><code>def inorderPredecessor(self, root, p):
    res = None
    while root:
        if root.val &gt;= p.val:
            root = root.left
        else:
            res = root
            root = root.right
    return res
</code></pre><p>##链表</p>
<h3 id="1反转列表">1.反转列表</h3>
<p>新开节点pre指向头节点<br>
cur为当前节点
nxt为cur的下个节点</p>
<p>cur指向pre<br>
pre来到cur的位置： pre = cur
cur来到nxt的位置： cur = nxt</p>
<pre tabindex="0"><code>pre, cur = None, head
while cur: #当有节点时
    nxt = cur.next  # 下一个要处理的节点
    cur.next = pre # 当前节点指向之前的节点
    pre = cur # 之前的节点变成当前节点
    cur = nxt # 当前的节点变成下一个节点
return pre
</code></pre><h3 id="2-有环链表">2. 有环链表</h3>
<p>快指针-走两步<br>
慢指针-走一步<br>
不为空，且重合，即有环，停止<br>
快指针回头，都变成慢指针走一步，重逢即入环节点</p>
<h3 id="3-删除倒数第n个节点">3. 删除倒数第n个节点</h3>
<p>快指针先走n步<br>
慢指针从头开始<br>
快指针结束时的节点即跳过删除</p>
<pre tabindex="0"><code>fast = ListNode(-1, head)
slow = fast
res = slow
while n:
    fast = fast.next
    n -= 1
while fast.next:
    slow = slow.next
    fast= fast.next
slow.next = slow.next.next
return res.next

</code></pre><h2 id="动态规划">动态规划</h2>
<p>最后一个元素的状态 = 前一个元素的最佳状态 + 当前可能存在的状态<br>
倒推到第1/2个元素的其实状态挨个计算</p>
<h3 id="最长无重复子串">最长无重复子串</h3>
<pre tabindex="0"><code>s = 'asdf'
l=r=0
n = len(s)
d = {}
res = 0
while r &lt; n:
    if s[r] in dic and d[s[r]] &gt;= l:
        l = d[s[r]] + 1
    d[s[r]] = r
    res = max(res, r-l+1)
    r += 1
return res
</code></pre><h3 id="最长回文子串">最长回文子串</h3>
<p>双指针，从头遍历,判断当前阶段的数组是否回文</p>
<p>每次分单/双数讨论，由中心向两边外拓展判断回文</p>
<pre tabindex="0"><code>def extending(s: str, l:int, r: int):
    while l &gt;= 0 and r &lt;=len(s) and s[l] == s[r]:
        l -= 1
        r += 1

    return l+1, r-1

a, b = 0, 0

for i in range(len(s)):
    l1, r1 = extending(s, i, i) # 单点为中心
    l2, r2 = extending(s, i, i+1) # 完全对称
    if r1 - l1 &gt; b-a:
        a, b = l1, r1
    if r2 - l2 &gt; b-a:
        a, b = l2, r
    
return s[a:b+1]
</code></pre><h3 id="最大容器">最大容器</h3>
<p>双指针遍历，头/尾靠拢
目标值 = 数组长度 * 两边高度取小
高度不确定，所以从长度入手
双变量定性分析，从可控的入手</p>
<pre tabindex="0"><code>high = [1,2,3,4,5,6]
l = 0
r = len(list) -1
res = 0
while l &lt; r:
    if high[l] &lt; high[r]:
        res = max(res, high[l]*(r-l))
        l += 1
    else:
        res = max(res, high[r]*(r-l))
        r -= 1

</code></pre><h3 id="三数之和">三数之和</h3>
<p>排序后<br>
三指针：<br>
指针一 挨个遍历<br>
指针二 左边界  指针1的下一个数<br>
指针三 右边界  数组的最后一个数</p>
<pre tabindex="0"><code>def threeSum(self, nums: List[int]) -&gt; List[List[int]]:
        n = len(nums)
        if n &lt; 3:
            return []
        nums.sort() 
        res = []
        for i in range(n):
            if nums[i] &gt; 0:
                return res
                # 排序后，当前最小值已经＞0，后续结果肯定&gt;0 跳出
            if i &gt; 0 and nums[i] == nums[i-1]:
                continue
                # 相同的数不能多次计算造成重复
            l = i + 1 # 左指针
            r = n - 1 # 右指针
            while l &lt; r:
                s = nums[i] + nums[l] + nums[r] # 当前和
               if s == 0: # 成功匹配，加入结果
                    res.append([nums[i], nums[l], nums[r]])
                    while l &lt; r and nums[l] == nums[l+1]:
                        l = l + 1 # 重读数移动
                    while l &lt; r and nums[r] == nums[r-1]:
                        r = r - 1 # 重读数移动
                    l = l + 1 
                    r = r - 1
                    # 双指针都动，进到下一次判断
               elif s &gt; 0:
                    r = r - 1 # 和太大，先从右指针左移
               else:
                    l = l + 1 # 和太小，先从左指针右移
                
        return res

</code></pre></div>
        <div class="post-footer">
            <div class="info">
                
                
            </div>
        </div>

        
    </div>


            </div>
        </div>
    </main>
</div><footer class="footer footer--base">        
    <div class="by_farbox">
        <ul class="footer__list">
            <li class="footer__item">&copy;
                
                    Chi Feng 2024
                
            </li>
            
        </ul>
    </div>
</footer>

<script type="text/javascript"
        src="/js/medium-zoom.min.83cb1dd5fea8d42d87d1e601a07faa73089ad0ef9ccfe5daf6041289ebcc4e46.js"
        integrity="sha256-g8sd1f6o1C2H0eYBoH&#43;qcwia0O&#43;cz&#43;Xa9gQSievMTkY="
        crossorigin="anonymous"></script></body>

</html>
